

#Рассмотрим cложность алгоритма сортировки выбором (selection sort) и  возможные оптимизации.
def selection_sort(arr):
   # Проходим по всему списку
   for i in range(len(arr)):
       # Предполагаем, что первый элемент в неотсортированной части - это минимальный
       min_index = i
       # Ищем минимальный элемент в оставшейся части списка
       for j in range(i+1, len(arr)):
           if arr[j] < arr[min_index]:
               min_index = j
       # Меняем местами найденный минимальный элемент с первым элементом в неотсортированной части
       arr[i], arr[min_index] = arr[min_index], arr[i]

# Пример использования
numbers = [64, 25, 12, 22, 11]
selection_sort(numbers)
print(numbers)  # [11, 12, 22, 25, 64]

#Алгоритм сортировки выбором (selection sort) имеет временную сложность
# \( O(n^2) \), где \( n \) — количество элементов в массиве.
# Эта оценка справедлива как для лучшего, так и для худшего случаев,
# так как алгоритм всегда проходит через список дважды: первый раз для
# поиска минимального элемента и второй раз для обмена его местами.




# Анализ сложности:

#1. **Временная сложность:**
   #- Внешний цикл выполняется \( n \) раз.
   #- Внутренний цикл выполняется \( n-i-1 \) раз для каждого значения \( i \).
   #- Итоговая сложность: \( \sum_{i=0}^{n-1} (n-i-1) = \frac{n(n-1)}{2} \),
# что в асимптотическом выражении даёт \( O(n^2) \).

#2. **Пространственная сложность:**
   #- Алгоритм использует \( O(1) \) дополнительной памяти, так как все операции выполняются на
# исходном массиве и не требуют дополнительных структур данных.

# Возможные оптимизации:

#1. **Использование другого алгоритма:**
   #- **Пузырьковая сортировка**: В худшем случае имеет ту же сложность \( O(n^2) \), но простота
# реализации может быть преимуществом.
   #- **Сортировка вставками**: Тоже \( O(n^2) \), но лучше работает на почти отсортированных данных.
   #- **Сортировка слиянием**: \( O(n \log n) \) во всех случаях, но требует дополнительной памяти.
   #- **Быстрая сортировка (Quick Sort)**: Средняя сложность \( O(n \log n) \), но в худшем случае \( O(n^2) \).
# Обычно является одной из самых быстрых на практике.
   #- **Пирамидальная сортировка (Heap Sort)**: \( O(n \log n) \) во всех случаях и
# использует \( O(1) \) дополнительной памяти.

#2. **Оптимизация выбора минимального элемента:**
   #- Для небольших массивов или учебных целей можно оставить алгоритм без изменений.
   #- Если необходимо улучшить производительность, рассмотрите возможность использования
# бинарного поиска для вставки элементов, что может уменьшить время поиска.



### Код с использованием более эффективного алгоритма:

#Вот пример реализации быстрой сортировки, которая в среднем работает быстрее, чем сортировка выбором:


def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Пример использования
numbers = [64, 25, 12, 22, 11]
sorted_numbers = quick_sort(numbers)
print(sorted_numbers)  # [11, 12, 22, 25, 64]


#Этот алгоритм, в среднем, имеет временную сложность \( O(n \log n) \) и часто показывает
# лучшую производительность для большинства наборов данных по сравнению с сортировкой выбором.